"use strict";
/*
 Code from http://www.onlinespiele-sammlung.de/tetris/tetrisgames/bitbar/bake.html
 Modified by Jonas Kugelmann
 */

var a;

var SHAPE = [ [ [ [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 1, 1, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 1, 1, 1, 1 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ] ], [ [ [ 0, 1, 0, 0 ], [ 1, 1, 1, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 1, 1, 1, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 1, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 0 ] ] ], [ [ [ 0, 1, 0, 0 ], [ 1, 1, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 1, 0, 0 ], [ 1, 1, 0, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 0, 0 ] ] ], [ [ [ 0, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ] ] ], [ [ [ 1, 1, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 1, 1, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 1, 1, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 1, 1, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ] ], [ [ [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 1, 1, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 1, 0, 0, 0 ], [ 1, 1, 1, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 1, 1, 0 ], [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 1, 1, 1, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 0 ] ] ], [ [ [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 1, 1, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 0, 0, 0 ], [ 1, 1, 1, 0 ], [ 1, 0, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 1, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 0, 0 ] ], [ [ 0, 0, 1, 0 ], [ 1, 1, 1, 0 ], [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ] ] ] ];

var COLOR = [ "#000000", "#FF5555", "#5555FF", "#55FF55", "#EEEE55", "#FFCA25", "#55FFFF", "#FF55FF", "#FF0000", "#FFFFFF" ];

var FIELDCODE = 65;

var OVERALL_WAIT = 250;

var USECOLOR = 1;

var D_NONE = 0;

var D_UP = 1;

var D_DOWN = 2;

var D_LEFT = 3;

var D_RIGHT = 4;

var D_CWISE = 5;

var D_CCWISE = 6;

var S_NONE = 0;

var S_DROPBLOCK = 1;

var S_DROPLINES = 2;

var S_FILLFIELD = 3;

var S_FADELINES = 4;

var GeneralTimer = 0;

window.setInterval(timerfunction, 25);

function timerfunction() {
    GeneralTimer += 25;
}

function random(n) {
    return Math.floor(Math.random() * n);
}

function gametimer() {
    return GeneralTimer;
}

function FIELD() {
    this.frame_pad = this.block_pad = this.block_height = this.block_width = this.bottom = this.right = this.top = this.left = this.height = this.width = 0;
    this.frame_col = "#FFFFFF";
    this.grid_col = "#000000";
    this.displayid = this.display = this.efield = this.view = this.data = undefined;
    this.tetris = new TETRIS();
}

FIELD.prototype.findmoves = function() {
    var b, c = -2e3, d, g, f, e = this.tetris;
    d = e.shape_x;
    g = e.shape_y;
    f = e.shape_a;
    this.delashape();
    for (e.shape_x = -1; e.shape_x < this.width; e.shape_x++) {
        for (e.shape_a = 0; e.shape_a < 4; e.shape_a++) {
            for (e.shape_y = 1; !this.testshape() && e.shape_y < this.height; ) {
                e.shape_y++;
            }
            e.shape_y--;
            if (!this.testshape()) {
                this.putashape();
                b = this.evalfield();
                if (c < b) {
                    c = b;
                    e.best_a = e.shape_a;
                    e.best_x = e.shape_x;
                    e.best_y = e.shape_y;
                }
                this.delashape();
            }
        }
    }
    this.tetris.shape_a = f;
    this.tetris.shape_x = d;
    this.tetris.shape_y = g;
    this.putashape();
};

FIELD.prototype.droplines = function() {
    var x;
    if ((x = this.tetris.counter) === 4) {
        this.tetris.wait_time = OVERALL_WAIT - this.tetris.curr_level;
        this.tetris.game_status = S_NONE;
    } else if (this.tetris.drop_line[x] >= 0) {
        for (var y = this.tetris.drop_line[x]; y > 0; y--) {
            for (x = 0; x < this.width; x++) {
                this.data[x + y * this.width] = this.data[x + (y - 1) * this.width];
            }
        }
        for (var i = 0; i < this.width; i++) {
            this.data[i] = 0;
        }
        this.tetris.counter++;
    } else {
        this.tetris.wait_time = OVERALL_WAIT - this.tetris.curr_level;
        this.tetris.game_status = S_NONE;
    }
};

FIELD.prototype.fadelines = function(instantmove) {
    var y;
    if (instantmove) {
        for (var x = 0; x < this.width; x++) {
            for (y = 0; y < 4; y++) {
                if (this.tetris.drop_line[y] >= 0) {
                    this.data[x + this.tetris.drop_line[y] * this.width] = 9;
                }
            }
        }
        this.tetris.game_status = S_DROPLINES;
        this.tetris.counter = 0;
    } else {
        for (y = 0; y < 4; y++) {
            if (this.tetris.drop_line[y] >= 0) {
                this.data[this.tetris.counter + this.tetris.drop_line[y] * this.width] = 0;
                this.data[this.width - 1 - this.tetris.counter + this.tetris.drop_line[y] * this.width] = 0;
            }
        }
        this.tetris.counter++;
        if (this.width - this.tetris.counter <= this.tetris.counter) {
            this.tetris.game_status = S_DROPLINES;
            this.tetris.counter = 0;
        }
    }
};

FIELD.prototype.horizline = function() {
    var b, c, d = 0, g;
    for (c = 0; c < this.height; c++) {
        g = 1;
        for (b = 0; g && b < this.width; b++) {
            this.data[b + c * this.width] || (g = 0);
        }
        if (g) {
            this.tetris.drop_line[d++] = c;
            this.tetris.game_status = S_FADELINES;
            this.tetris.counter = 0;
        }
    }
    if (d) {
        this.tetris.wait_time = 1;
        this.tetris.move_down = 0;
        for (this.tetris.rows_completed += d; d < 4; d++) {
            this.tetris.drop_line[d] = -1;
        }
    }
};

FIELD.prototype.nextshape = function(b) {
    this.tetris.curr_shape = this.tetris.next_shape;
    this.tetris.next_shape = random(7);
    this.tetris.shape_x = this.width / 2 - 2;
    this.tetris.shape_y = 0;
    this.tetris.shape_a = 0;
    this.tetris.best_a = -1;
    this.tetris.best_x = 0;
    this.tetris.best_y = 0;
    this.tetris.block_drawn = 0;
    this.tetris.wait_time = OVERALL_WAIT - this.tetris.curr_level;
    if (b !== 1) {
        this.messageframe.innerHTML = "Rows: " + this.tetris.rows_completed + " &nbsp; Next: " + PIECENAMES[this.tetris.next_shape];
    }
};

FIELD.prototype.evalfield = function() {
    var x, y, i, full, empty, btype, well, blocked, lblock, rblock;
    var HorizontalTransitions = 0;
    var FilledLines = 0;
    var HighestBlock = -1;
    var VerticalTransitions = 0;
    var BlockedCells = 0;
    var Wells = 0;
    for (i = y = this.height - 1; y >= 0; y--) {
        btype = 1;
        full = 1;
        empty = 1;
        for (x = this.width - 1; x >= 0; x--) {
            if (this.data[x + y * this.width] == 0) this.efield[x + i * this.width] = 0; else empty = !(this.efield[x + i * this.width] = 1);
            if (btype != this.efield[x + i * this.width]) {
                btype = this.efield[x + i * this.width];
                full = 0;
                HorizontalTransitions++;
            }
        }
        if (!empty) HighestBlock = -1;
        if (empty && HighestBlock == -1) HighestBlock = this.height - (y + 1);
        if (!full) i--; else for (x = this.width - 1; x >= 0; x--) this.efield[x + y * this.width] = 0;
        if (!btype) HorizontalTransitions++;
    }
    if (HighestBlock == -1) HighestBlock = this.height;
    FilledLines = i + 1;
    HighestBlock -= FilledLines;
    for (x = 0; x < this.width; x++) {
        btype = 0;
        blocked = 0;
        for (y = this.height - HighestBlock; y < this.height; y++) {
            if (btype != this.efield[x + y * this.width]) {
                blocked = 1;
                btype = this.efield[x + y * this.width];
                VerticalTransitions++;
            }
            if (blocked && !this.efield[x + y * this.width]) {
                BlockedCells++;
            }
            if (x == 0) lblock = 1; else lblock = this.efield[x - 1 + y * this.width];
            if (x == this.width - 1) rblock = 1; else rblock = this.efield[x + 1 + y * this.width];
            if (lblock && rblock) {
                for (i = y; i < this.height && this.efield[x + i * this.width] == 0; i++) Wells++;
            }
        }
        if (!btype) VerticalTransitions++;
    }
    if (random(15) > 8) {
        return -1 * HighestBlock + -1 * HorizontalTransitions + -1 * VerticalTransitions + -4 * BlockedCells;
    } else {
        return -1 * HighestBlock + -1 * HorizontalTransitions + -1 * VerticalTransitions + -4 * BlockedCells + -.9 * Wells + .1 * FilledLines;
    }
};

function TETRIS() {
    this.wait_time = this.curr_level = this.best_a = this.best_y = this.best_x = this.shape_a = this.shape_y = this.shape_x = this.next_shape = this.curr_shape = 0;
    this.drop_line = new Array(4);
    this.gameover = this.rows_completed = this.move_down = this.block_drawn = this.counter = this.game_status = 0;
}

TETRIS.prototype.setTetris = function() {
    this.curr_level = this.best_a = this.best_y = this.best_x = this.shape_a = this.shape_y = this.shape_x = this.next_shape = this.curr_shape = 0;
    this.wait_time = OVERALL_WAIT;
    this.counter = this.block_drawn = this.move_down = 0;
    this.game_status = S_NONE;
};

a = FIELD.prototype;

a.cpuplayer = function(instantmove) {
    var action;
    var stillmoving;
    switch (this.tetris.game_status) {
      case S_NONE:
        if (!this.tetris.block_drawn) {
            this.tetris.block_drawn = 1;
            if (this.testshape()) {
                this.tetris.gameover = 1;
            } else {
                this.putashape();
            }
        }
        this.tetris.best_a === -1 && this.findmoves();
        if (instantmove) {
            for (stillmoving = 1; stillmoving; ) {
                action = D_DOWN;
                if (this.tetris.shape_a !== -1) {
                    if (this.tetris.shape_x < this.tetris.best_x) {
                        action = D_RIGHT;
                    }
                    if (this.tetris.shape_x > this.tetris.best_x) {
                        action = D_LEFT;
                    }
                    if (this.tetris.shape_a !== this.tetris.best_a) {
                        action = D_CWISE;
                    }
                }
                if (!this.moveshape(action)) {
                    if (action === D_DOWN) {
                        this.nextshape(instantmove);
                        this.horizline();
                        stillmoving = 0;
                    } else if (!this.moveshape(D_DOWN)) {
                        this.nextshape(instantmove);
                        this.horizline();
                        stillmoving = 0;
                    }
                }
            }
        } else if (this.tetris.move_down < gametimer()) {
            this.tetris.move_down = gametimer() + 1;
            action = D_DOWN;
            if (this.tetris.shape_x < this.tetris.best_x) {
                action = D_RIGHT;
            }
            if (this.tetris.shape_x > this.tetris.best_x) {
                action = D_LEFT;
            }
            if (this.tetris.shape_a !== this.tetris.best_a) {
                action = D_CWISE;
            }
            this.tetris.counter++;
            this.tetris.counter %= 5;
            this.tetris.counter || (action = D_DOWN);
            if (!this.moveshape(action) && action === D_DOWN) {
                this.nextshape();
                this.horizline();
            }
        }
        break;

      case S_DROPLINES:
        if (this.tetris.move_down < gametimer()) {
            this.tetris.move_down = gametimer() + 1;
            this.droplines();
        }
        break;

      case S_FADELINES:
        if (this.tetris.move_down < gametimer()) {
            this.tetris.move_down = gametimer() + 1;
            this.fadelines(instantmove);
        }
        break;
    }
};

a.userinput = function() {
    var keyCode, action = D_NONE;
    if (kbhit()) {
        keyCode = getch();
        switch (keyCode) {
          case 38:
            action = D_CWISE;
            break;

          case 37:
            action = D_LEFT;
            break;

          case 39:
            action = D_RIGHT;
            break;

          case 40:
            action = D_DOWN;
            break;

          default:
            break;
        }
        if (keyCode === 27) {
            this.tetris.gameover = 1;
        }
        if (keyCode === 32 && this.tetris.game_status === S_NONE) {
            this.tetris.game_status = S_DROPBLOCK;
            this.tetris.wait_time = 1;
            this.tetris.move_down = 0;
        }
    }
    switch (this.tetris.game_status) {
      case S_NONE:
        if (!this.tetris.block_drawn) {
            this.tetris.block_drawn = 1;
            if (this.testshape()) {
                this.tetris.gameover = 1;
            } else {
                this.putashape();
            }
        }
        if (action !== D_NONE) {
            if (this.moveshape(action) && action === D_DOWN) {
                this.tetris.move_down = gametimer() + this.tetris.wait_time;
            }
        }
        if (this.tetris.move_down < gametimer()) {
            this.tetris.move_down = gametimer() + this.tetris.wait_time;
            if (!this.moveshape(D_DOWN)) {
                this.nextshape();
                this.horizline();
            }
        }
        break;

      case S_DROPBLOCK:
        this.moveshape(action);
        if (this.tetris.move_down < gametimer()) {
            this.tetris.move_down = gametimer() + this.tetris.wait_time;
            if (!this.moveshape(D_DOWN)) {
                this.tetris.game_status = S_NONE;
                this.nextshape();
                this.horizline();
            }
        }
        break;

      case S_DROPLINES:
        if (this.tetris.move_down < gametimer()) {
            this.tetris.move_down = gametimer() + this.tetris.wait_time;
            this.droplines();
        }
        break;

      case S_FADELINES:
        if (this.tetris.move_down < gametimer()) {
            this.tetris.move_down = gametimer() + this.tetris.wait_time;
            this.fadelines();
        }
        break;
    }
};

a.moveshape = function(action) {
    if (action === D_NONE) {
        return 1;
    }
    this.delashape();
    switch (action) {
      case D_UP:
        this.tetris.shape_y--;
        break;

      case D_DOWN:
        this.tetris.shape_y++;
        break;

      case D_LEFT:
        this.tetris.shape_x--;
        break;

      case D_RIGHT:
        this.tetris.shape_x++;
        break;

      case D_CWISE:
        this.tetris.shape_a++;
        this.tetris.shape_a %= 4;
        break;

      case D_CCWISE:
        this.tetris.shape_a += 3;
        this.tetris.shape_a %= 4;
        break;
    }
    var c = !this.testshape();
    if (!c) {
        switch (action) {
          case D_UP:
            this.tetris.shape_y++;
            break;

          case D_DOWN:
            this.tetris.shape_y--;
            break;

          case D_LEFT:
            this.tetris.shape_x++;
            break;

          case D_RIGHT:
            this.tetris.shape_x--;
            break;

          case D_CWISE:
            this.tetris.shape_a += 3;
            this.tetris.shape_a %= 4;
            break;

          case D_CCWISE:
            this.tetris.shape_a++;
            this.tetris.shape_a %= 4;
            break;
        }
    }
    this.putashape();
    return c;
};

a.testshape = function() {
    var d = this.tetris.curr_shape, g = this.tetris.shape_a, f = this.tetris.shape_x, e = this.tetris.shape_y;
    for (var c = 0; c < 4; c++) {
        for (var b = 0; b < 4; b++) {
            if (SHAPE[d][g][c][b]) {
                if (b + f < this.width && c + e < this.height && b + f >= 0 && c + e >= 0) {
                    if (this.data[b + f + (c + e) * this.width]) {
                        return true;
                    }
                } else {
                    return true;
                }
            }
        }
    }
    return false;
};

a.putashape = function() {
    var d = this.tetris.curr_shape, g = this.tetris.shape_a, f = this.tetris.shape_x, e = this.tetris.shape_y;
    for (var c = 0; c < 4; c++) {
        for (var b = 0; b < 4; b++) {
            if (b + f < this.width && c + e < this.height && b + f >= 0 && c + e >= 0) {
                if (SHAPE[d][g][c][b]) {
                    this.data[b + f + (c + e) * this.width] = d + 1;
                }
            }
        }
    }
};

a.delashape = function() {
    var d = this.tetris.curr_shape, g = this.tetris.shape_a, f = this.tetris.shape_x, e = this.tetris.shape_y;
    for (var c = 0; c < 4; c++) {
        for (var b = 0; b < 4; b++) {
            if (b + f < this.width && c + e < this.height && b + f >= 0 && c + e >= 0) {
                if (SHAPE[d][g][c][b]) {
                    this.data[b + f + (c + e) * this.width] = 0;
                }
            }
        }
    }
};

a.plotframe = function() {
    var b = this.block_height + 3, c = this.top - this.frame_pad, d = this.left - this.frame_pad, g = this.right + this.frame_pad - d, f = this.bottom + this.frame_pad - c;
    var temp;
    this.outerframe = temp = document.createElement("DIV");
    temp.style.top = c;
    temp.style.left = d;
    temp.style.height = f;
    temp.style.width = g;
    temp.style.position = "absolute";
    temp.style.background = this.frame_col;
    temp.style.overflow = "hidden";
    document.body.insertBefore(temp, PlaceHolder);
    this.innerframe = temp = document.createElement("DIV");
    temp.style.top = c + 1;
    temp.style.left = d + 1;
    temp.style.height = f - 2;
    temp.style.width = g - 2;
    temp.style.position = "absolute";
    temp.style.background = this.grid_col;
    temp.style.overflow = "hidden";
    document.body.insertBefore(temp, PlaceHolder);
    this.messageframeborder = temp = document.createElement("DIV");
    temp.style.top = c - b;
    temp.style.left = d;
    temp.style.height = b - 1;
    temp.style.width = g;
    temp.style.position = "absolute";
    temp.style.background = this.frame_col;
    temp.style.overflow = "hidden";
    document.body.insertBefore(temp, PlaceHolder);
    this.messageframe = temp = document.createElement("DIV");
    temp.style.top = c - b + 1;
    temp.style.left = d + 1;
    temp.style.height = b - 3;
    temp.style.width = g - 2;
    temp.style.position = "absolute";
    temp.style.background = "#000000";
    temp.style.overflow = "hidden";
    document.body.insertBefore(temp, PlaceHolder);
};

a.putsquare = function(x, y, color) {
    this.display[x + y * this.width].style.background = color;
};

a.createfield = function() {
    var d;
    this.displayidprefix = String.fromCharCode(FIELDCODE++);
    for (var c = 0; c < this.height; c++) {
        for (var b = 0; b < this.width; b++) {
            d = document.createElement("SPAN");
            d.style.top = (this.block_pad + this.block_height) * c + this.top;
            d.style.left = (this.block_pad + this.block_width) * b + this.left;
            d.style.height = this.block_height;
            d.style.width = this.block_width;
            d.style.position = "absolute";
            d.style.background = "#000000";
            d.style.overflow = "hidden";
            if (this.editable) {
                is_ie ? d.attachEvent("onclick", OnBlockClick) : d.addEventListener("onclick", OnBlockClick, false);
            }
            document.body.insertBefore(this.display[b + c * this.width] = d, PlaceHolder);
        }
    }
};

a.plotfield = function() {
    for (var y = 0; y < this.height; y++) {
        for (var x = 0; x < this.width; x++) {
            if (this.view[x + y * this.width] !== this.data[x + y * this.width]) {
                this.putsquare(x, y, COLOR[this.view[x + y * this.width] = this.data[x + y * this.width]]);
            }
        }
    }
};

a.pluckfield = function() {
    var x, y;
    for (y = 0; y < this.height; y++) {
        for (x = 0; x < this.width; x++) {
            if (!!this.getsquare(x, y) === !this.view[x + y * this.width]) {
                this.data[x + y * this.width] = 8 * this.getsquare(x, y);
            }
        }
    }
};

a.getsquare = function(x, y) {
    return this.display[x + y * this.width].style.background !== "#000000";
};

a.freefield = function() {
    this.display = this.view = this.data = undefined;
    this.height = this.width = null;
};

a.makefield = function(width, height) {
    this.data = new Array(height * width);
    this.view = new Array(height * width);
    this.efield = new Array(height * width);
    this.display = new Array(height * width);
    this.width = width;
    this.height = height;
};

a.initfield = function(b, c, d, g, f, e) {
    this.left = b;
    this.top = c;
    this.right = b + (d + f) * this.width - f;
    this.bottom = c + (g + f) * this.height - f;
    this.block_width = d;
    this.block_height = g;
    this.frame_pad = e;
    this.block_pad = f;
    this.frame_col = "#FFCCFF";
    this.grid_col = "#303030";
    for (var i = 0; i < this.height * this.width; i++) {
        this.data[i] = 0;
        this.view[i] = 0;
    }
    this.tetris.setTetris();
};

a.wipefield = function() {
    for (var i = 0; i < this.height * this.width; i++) {
        this.data[i] = 0;
    }
};

function FIFO(a) {
    if (a == undefined) a = 20;
    this.BufferSize = a;
    this.Buffer = new Array(a);
    this.BufferRead = 0;
    this.BufferWrite = 1;
    for (var b = this.length = 0; b < a; b++) this.Buffer[b] = 0;
}

FIFO.prototype.Write = function FIFOwrite(b) {
    if (this.BufferWrite == this.BufferRead) return 0;
    this.Buffer[this.BufferWrite] = b;
    this.BufferWrite = ++this.BufferWrite % this.BufferSize;
    return ++this.length;
};

FIFO.prototype.Read = function FIFOread() {
    if (this.length) {
        this.length--;
        return this.Buffer[this.BufferRead = (1 + this.BufferRead) % this.BufferSize];
    }
};

"use strict";

var KeyStatus = new Array(256), KeyboardBufferSize = 20, KeyboardBuffer = new FIFO(KeyboardBufferSize), KeyboardInitialRepeatDelay = 200, KeyboardRepeatDelay = 50, KeyboardBlockKeys = 0;

if (is_ie) {
    window.attachEvent("onload", InitKeyboardHandler);
} else {
    window.addEventListener("load", InitKeyboardHandler, false);
    window.captureEvents(Event.KEYUP);
    window.captureEvents(Event.KEYDOWN);
}

document.onkeydown = KeydownHandler;

document.onkeyup = KeyupHandler;

function KeyRepeater(a, b) {
    KeyboardBuffer.Write(a);
    KeyStatus[a] = setTimeout("KeyRepeater(" + a + "," + KeyboardRepeatDelay + ");", b);
}

function FindKeyCode(a) {
    if (!a) {
        if (window.event) {
            a = window.event;
        } else {
            return;
        }
    }
    if (typeof a.which === "number") {
        a = a.which;
    } else if (typeof a.keyCode === "number") {
        a = a.keyCode;
    } else if (typeof a.charCode === "number") {
        a = a.charCode;
    } else {
        return;
    }
    return a;
}

function KeyupHandler(a) {
    a = FindKeyCode(a);
    clearTimeout(KeyStatus[a]);
    KeyStatus[a] = 0;
}

function KeydownHandler(a) {
    a = FindKeyCode(a);
    KeyStatus[a] || (KeyStatus[a] = setTimeout("KeyRepeater(" + a + "," + KeyboardInitialRepeatDelay + ");", 0));
    if (KeyboardBlockKeys) {
        return false;
    }
}

function InitKeyboardHandler() {
    var a;
    for (a = 0; a < 256; a++) {
        KeyStatus[a] = 0;
    }
}

function kbhit() {
    return KeyboardBuffer.length;
}

function getch() {
    return KeyboardBuffer.Read();
}

var agt = navigator.userAgent.toLowerCase(), is_major = parseInt(navigator.appVersion), is_minor = parseFloat(navigator.appVersion), is_nav = agt.indexOf("mozilla") != -1 && agt.indexOf("spoofer") == -1 && agt.indexOf("compatible") == -1 && agt.indexOf("opera") == -1 && agt.indexOf("webtv") == -1 && agt.indexOf("hotjava") == -1, is_nav2 = is_nav && is_major == 2, is_nav3 = is_nav && is_major == 3, is_nav4 = is_nav && is_major == 4, is_nav4up = is_nav && is_major >= 4, is_navonly = is_nav && (agt.indexOf(";nav") != -1 || agt.indexOf("; nav") != -1), is_nav6 = is_nav && is_major == 5, is_nav6up = is_nav && is_major >= 5, is_gecko = agt.indexOf("gecko") != -1, is_ie = agt.indexOf("msie") != -1 && agt.indexOf("opera") == -1, is_ie3 = is_ie && is_major < 4, is_ie4 = is_ie && is_major == 4 && agt.indexOf("msie 4") != -1, is_ie4up = is_ie && is_major >= 4, is_ie5 = is_ie && is_major == 4 && agt.indexOf("msie 5.0") != -1, is_ie5_5 = is_ie && is_major == 4 && agt.indexOf("msie 5.5") != -1, is_ie5up = is_ie && !is_ie3 && !is_ie4, is_ie5_5up = is_ie && !is_ie3 && !is_ie4 && !is_ie5, is_ie6 = is_ie && is_major == 4 && agt.indexOf("msie 6.") != -1, is_ie6up = is_ie && !is_ie3 && !is_ie4 && !is_ie5 && !is_ie5_5, is_aol = agt.indexOf("aol") != -1, is_aol3 = is_aol && is_ie3, is_aol4 = is_aol && is_ie4, is_aol5 = agt.indexOf("aol 5") != -1, is_aol6 = agt.indexOf("aol 6") != -1, is_opera = agt.indexOf("opera") != -1, is_opera2 = agt.indexOf("opera 2") != -1 || agt.indexOf("opera/2") != -1, is_opera3 = agt.indexOf("opera 3") != -1 || agt.indexOf("opera/3") != -1, is_opera4 = agt.indexOf("opera 4") != -1 || agt.indexOf("opera/4") != -1, is_opera5 = agt.indexOf("opera 5") != -1 || agt.indexOf("opera/5") != -1, is_opera5up = is_opera && !is_opera2 && !is_opera3 && !is_opera4, is_webtv = agt.indexOf("webtv") != -1, is_TVNavigator = agt.indexOf("navio") != -1 || agt.indexOf("navio_aoltv") != -1, is_AOLTV = is_TVNavigator, is_hotjava = agt.indexOf("hotjava") != -1, is_hotjava3 = is_hotjava && is_major == 3, is_hotjava3up = is_hotjava && is_major >= 3, is_js;

is_js = is_nav2 || is_ie3 ? 1 : is_nav3 ? 1.1 : is_opera5up ? 1.3 : is_opera ? 1.1 : is_nav4 && is_minor <= 4.05 || is_ie4 ? 1.2 : is_nav4 && is_minor > 4.05 || is_ie5 ? 1.3 : is_hotjava3up ? 1.4 : is_nav6 || is_gecko ? 1.5 : is_nav6up ? 1.5 : is_ie5up ? 1.3 : 0;

var is_win = agt.indexOf("win") != -1 || agt.indexOf("16bit") != -1, is_win95 = agt.indexOf("win95") != -1 || agt.indexOf("windows 95") != -1, is_win16 = agt.indexOf("win16") != -1 || agt.indexOf("16bit") != -1 || agt.indexOf("windows 3.1") != -1 || agt.indexOf("windows 16-bit") != -1, is_win31 = agt.indexOf("windows 3.1") != -1 || agt.indexOf("win16") != -1 || agt.indexOf("windows 16-bit") != -1, is_winme = agt.indexOf("win 9x 4.90") != -1, is_win2k = agt.indexOf("windows nt 5.0") != -1, is_win98 = agt.indexOf("win98") != -1 || agt.indexOf("windows 98") != -1, is_winnt = agt.indexOf("winnt") != -1 || agt.indexOf("windows nt") != -1, is_win32 = is_win95 || is_winnt || is_win98 || is_major >= 4 && navigator.platform == "Win32" || agt.indexOf("win32") != -1 || agt.indexOf("32bit") != -1, is_os2 = agt.indexOf("os/2") != -1 || navigator.appVersion.indexOf("OS/2") != -1 || agt.indexOf("ibm-webexplorer") != -1, is_mac = agt.indexOf("mac") != -1;

if (is_mac && is_ie5up) is_js = 1.4;

var is_mac68k = is_mac && (agt.indexOf("68k") != -1 || agt.indexOf("68000") != -1), is_macppc = is_mac && (agt.indexOf("ppc") != -1 || agt.indexOf("powerpc") != -1), is_sun = agt.indexOf("sunos") != -1, is_sun4 = agt.indexOf("sunos 4") != -1, is_sun5 = agt.indexOf("sunos 5") != -1, is_suni86 = is_sun && agt.indexOf("i86") != -1, is_irix = agt.indexOf("irix") != -1, is_irix5 = agt.indexOf("irix 5") != -1, is_irix6 = agt.indexOf("irix 6") != -1 || agt.indexOf("irix6") != -1, is_hpux = agt.indexOf("hp-ux") != -1, is_hpux9 = is_hpux && agt.indexOf("09.") != -1, is_hpux10 = is_hpux && agt.indexOf("10.") != -1, is_aix = agt.indexOf("aix") != -1, is_aix1 = agt.indexOf("aix 1") != -1, is_aix2 = agt.indexOf("aix 2") != -1, is_aix3 = agt.indexOf("aix 3") != -1, is_aix4 = agt.indexOf("aix 4") != -1, is_linux = agt.indexOf("inux") != -1, is_sco = agt.indexOf("sco") != -1 || agt.indexOf("unix_sv") != -1, is_unixware = agt.indexOf("unix_system_v") != -1, is_mpras = agt.indexOf("ncr") != -1, is_reliant = agt.indexOf("reliantunix") != -1, is_dec = agt.indexOf("dec") != -1 || agt.indexOf("osf1") != -1 || agt.indexOf("dec_alpha") != -1 || agt.indexOf("alphaserver") != -1 || agt.indexOf("ultrix") != -1 || agt.indexOf("alphastation") != -1, is_sinix = agt.indexOf("sinix") != -1, is_freebsd = agt.indexOf("freebsd") != -1, is_bsd = agt.indexOf("bsd") != -1, is_unix = agt.indexOf("x11") != -1 || is_sun || is_irix || is_hpux || is_sco || is_unixware || is_mpras || is_reliant || is_dec || is_sinix || is_aix || is_linux || is_bsd || is_freebsd, is_vms = agt.indexOf("vax") != -1 || agt.indexOf("openvms") != -1;

"use strict";

var Analytics = function() {
    var sessionID = UUIDjs.create().toString();
    //Hardcoded User id
    var uuid= '5f52b4dc-eafd-44f7-9b90-84f2123b5da7';
    var analytics = {};
    analytics.createEvent = function(type, params) {
        console.log("Sending Event :", type, params);
        var event = {
            type: type,
            timestamp: Date.now(),
            session:sessionID,
            uuid:uuid
        };
        if (params) {
            event.params = params;
        }
        io.socket.post("/api/event", event, function(data) {
            if (data.status && data.status !== 200) {
                console.error(data);
                return;
            }
            console.log("Created Event: ", data);
        });
    };
    return analytics;
}();